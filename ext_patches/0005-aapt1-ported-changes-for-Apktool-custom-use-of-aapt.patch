From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Connor Tumbleson <connor@sourcetoad.com>
Date: Mon, 21 Mar 2022 17:18:41 -0400
Subject: [PATCH 5/7] aapt1: ported changes for Apktool custom use of aapt

 - miui rules
 - forcedPackageId support
 - support uppercase letters in filenames
 - support 4 digit mnc/mcc values
 - return early from functions that modify resources for compatibility
 - remove constraint on AndroidManifest.xml being present on resource files
 - allow files to be named anything (ie remove reserved keywords)
 - loosen filetype rules to follow aapt2
 - make aapt static

Change-Id: I8fe8ba777a96d58bc63a1afdcf6c02c1a0ec6034
---
 libs/androidfw/ConfigDescription.cpp          |  32 +++-
 libs/androidfw/ResourceTypes.cpp              |  10 +-
 .../include/androidfw/ResourceTypes.h         | 122 +++++++-------
 tools/aapt/AaptAssets.cpp                     |   6 +-
 tools/aapt/AaptConfig.cpp                     |  27 +++-
 tools/aapt/Android.bp                         |  14 ++
 tools/aapt/Bundle.h                           |   5 +-
 tools/aapt/Main.cpp                           |  40 ++++-
 tools/aapt/Resource.cpp                       |  50 +++---
 tools/aapt/ResourceTable.cpp                  | 151 +++++++++---------
 tools/aapt/XMLNode.cpp                        |   6 +-
 tools/aapt/XMLNode.h                          |  35 ++--
 12 files changed, 308 insertions(+), 190 deletions(-)

diff --git a/libs/androidfw/ConfigDescription.cpp b/libs/androidfw/ConfigDescription.cpp
index 19ead9583eb2..516297110e6c 100644
--- a/libs/androidfw/ConfigDescription.cpp
+++ b/libs/androidfw/ConfigDescription.cpp
@@ -50,7 +50,7 @@ static bool parseMcc(const char* name, ResTable_config* out) {
   while (*c >= '0' && *c <= '9') {
     c++;
   }
-  if (*c != 0) return false;
+  if (*c != 0 && c - val != 4) return false;
   if (c - val != 3) return false;
 
   int d = atoi(val);
@@ -81,7 +81,7 @@ static bool parseMnc(const char* name, ResTable_config* out) {
     c++;
   }
   if (*c != 0) return false;
-  if (c - val == 0 || c - val > 3) return false;
+  if (c - val == 0 || c - val > 4) return false;
 
   if (out) {
     out->mnc = atoi(val);
@@ -300,6 +300,29 @@ static bool parseUiModeType(const char* name, ResTable_config* out) {
       out->uiMode = (out->uiMode & ~ResTable_config::MASK_UI_MODE_TYPE) |
                     ResTable_config::UI_MODE_TYPE_VR_HEADSET;
     return true;
+  } else if (strcmp(name, "smallui") == 0) {
+    if (out)
+      out->uiMode = (out->uiMode & ~ResTable_config::MASK_UI_MODE_TYPE) |
+                    0xC;
+    return true;
+  } else if (strcmp(name, "mediumui") == 0) {
+    if (out)
+      out->uiMode = (out->uiMode & ~ResTable_config::MASK_UI_MODE_TYPE) |
+                    0xD;
+    return true;
+  } else if (strcmp(name, "largeui") == 0) {
+    if (out)
+      out->uiMode = (out->uiMode & ~ResTable_config::MASK_UI_MODE_TYPE) |
+                    0xE;
+    return true;
+  } else if (strcmp(name, "hugeui") == 0) {
+    if (out)
+      out->uiMode = 0xF;
+    return true;
+  } else if (strcmp(name, "godzillaui") == 0) {
+    if (out)
+      out->uiMode = 0xB;
+    return true;
   }
 
   return false;
@@ -860,7 +883,10 @@ void ConfigDescription::ApplyVersionForCompatibility(
   }
 
   if (min_sdk > config->sdkVersion) {
-    config->sdkVersion = min_sdk;
+    // Apktool: We are skipping this entirely in apktool, because the application has
+    // already been built once. Doing this changes the application with implicit
+    // version information, which may not have been in the original.
+    // config->sdkVersion = min_sdk;
   }
 }
 
diff --git a/libs/androidfw/ResourceTypes.cpp b/libs/androidfw/ResourceTypes.cpp
index 13c5f8fc84e8..895d47696021 100644
--- a/libs/androidfw/ResourceTypes.cpp
+++ b/libs/androidfw/ResourceTypes.cpp
@@ -5495,7 +5495,7 @@ bool ResTable::stringToFloat(const char16_t* s, size_t len, Res_value* outValue)
     return false;
 }
 
-bool ResTable::stringToValue(Res_value* outValue, String16* outString,
+bool ResTable::stringToValue(const ssize_t FORCED_PACKAGE_ID, Res_value* outValue, String16* outString,
                              const char16_t* s, size_t len,
                              bool preserveSpaces, bool coerceType,
                              uint32_t attrID,
@@ -5649,7 +5649,7 @@ bool ResTable::stringToValue(Res_value* outValue, String16* outString,
                 }
 
                 uint32_t packageId = Res_GETPACKAGE(rid) + 1;
-                if (packageId != APP_PACKAGE_ID && packageId != SYS_PACKAGE_ID) {
+                if (packageId != APP_PACKAGE_ID && packageId != SYS_PACKAGE_ID && packageId != (uint32_t)FORCED_PACKAGE_ID) {
                     outValue->dataType = Res_value::TYPE_DYNAMIC_REFERENCE;
                 }
                 outValue->data = rid;
@@ -5670,7 +5670,7 @@ bool ResTable::stringToValue(Res_value* outValue, String16* outString,
                         outValue->data = rid;
                         outValue->dataType = Res_value::TYPE_DYNAMIC_REFERENCE;
                         return true;
-                    } else if (packageId == APP_PACKAGE_ID || packageId == SYS_PACKAGE_ID) {
+                    } else if (packageId == APP_PACKAGE_ID || packageId == SYS_PACKAGE_ID || packageId == (uint32_t)FORCED_PACKAGE_ID) {
                         // We accept packageId's generated as 0x01 in order to support
                         // building the android system resources
                         outValue->data = rid;
@@ -5816,7 +5816,7 @@ bool ResTable::stringToValue(Res_value* outValue, String16* outString,
             }
 
             uint32_t packageId = Res_GETPACKAGE(rid) + 1;
-            if (packageId != APP_PACKAGE_ID && packageId != SYS_PACKAGE_ID) {
+            if (packageId != APP_PACKAGE_ID && packageId != SYS_PACKAGE_ID && packageId != (uint32_t)FORCED_PACKAGE_ID) {
                 outValue->dataType = Res_value::TYPE_DYNAMIC_ATTRIBUTE;
             }
             outValue->data = rid;
@@ -5831,7 +5831,7 @@ bool ResTable::stringToValue(Res_value* outValue, String16* outString,
                     outValue->data = rid;
                     outValue->dataType = Res_value::TYPE_DYNAMIC_ATTRIBUTE;
                     return true;
-                } else if (packageId == APP_PACKAGE_ID || packageId == SYS_PACKAGE_ID) {
+                } else if (packageId == APP_PACKAGE_ID || packageId == SYS_PACKAGE_ID || packageId == (uint32_t)FORCED_PACKAGE_ID) {
                     // We accept packageId's generated as 0x01 in order to support
                     // building the android system resources
                     outValue->data = rid;
diff --git a/libs/androidfw/include/androidfw/ResourceTypes.h b/libs/androidfw/include/androidfw/ResourceTypes.h
index 2d27c34a9154..bbedc22a3078 100644
--- a/libs/androidfw/include/androidfw/ResourceTypes.h
+++ b/libs/androidfw/include/androidfw/ResourceTypes.h
@@ -286,7 +286,7 @@ struct Res_value
 
     // Always set to 0.
     uint8_t res0;
-        
+
     // Type of the data value.
     enum : uint8_t {
         // The 'data' is either 0 or 1, specifying this resource is either
@@ -627,7 +627,7 @@ struct ResXMLTree_cdataExt
 {
     // The raw CDATA character data.
     struct ResStringPool_ref data;
-    
+
     // The typed value of the character data if this is a CDATA node.
     struct Res_value typedData;
 };
@@ -640,7 +640,7 @@ struct ResXMLTree_namespaceExt
 {
     // The prefix of the namespace.
     struct ResStringPool_ref prefix;
-    
+
     // The URI of the namespace.
     struct ResStringPool_ref uri;
 };
@@ -653,7 +653,7 @@ struct ResXMLTree_endElementExt
 {
     // String of the full namespace of this element.
     struct ResStringPool_ref ns;
-    
+
     // String name of this node if it is an ELEMENT; the raw
     // character data if this is a CDATA node.
     struct ResStringPool_ref name;
@@ -668,28 +668,28 @@ struct ResXMLTree_attrExt
 {
     // String of the full namespace of this element.
     struct ResStringPool_ref ns;
-    
+
     // String name of this node if it is an ELEMENT; the raw
     // character data if this is a CDATA node.
     struct ResStringPool_ref name;
-    
+
     // Byte offset from the start of this structure where the attributes start.
     uint16_t attributeStart;
-    
+
     // Size of the ResXMLTree_attribute structures that follow.
     uint16_t attributeSize;
-    
+
     // Number of attributes associated with an ELEMENT.  These are
     // available as an array of ResXMLTree_attribute structures
     // immediately following this node.
     uint16_t attributeCount;
-    
+
     // Index (1-based) of the "id" attribute. 0 if none.
     uint16_t idIndex;
-    
+
     // Index (1-based) of the "class" attribute. 0 if none.
     uint16_t classIndex;
-    
+
     // Index (1-based) of the "style" attribute. 0 if none.
     uint16_t styleIndex;
 };
@@ -698,13 +698,13 @@ struct ResXMLTree_attribute
 {
     // Namespace of this attribute.
     struct ResStringPool_ref ns;
-    
+
     // Name of this attribute.
     struct ResStringPool_ref name;
 
     // The original raw string value of this attribute.
     struct ResStringPool_ref rawValue;
-    
+
     // Processesd typed value of this attribute.
     struct Res_value typedValue;
 };
@@ -720,9 +720,9 @@ public:
         BAD_DOCUMENT = -1,
         START_DOCUMENT = 0,
         END_DOCUMENT = 1,
-        
-        FIRST_CHUNK_CODE = RES_XML_FIRST_CHUNK_TYPE, 
-        
+
+        FIRST_CHUNK_CODE = RES_XML_FIRST_CHUNK_TYPE,
+
         START_NAMESPACE = RES_XML_START_NAMESPACE_TYPE,
         END_NAMESPACE = RES_XML_END_NAMESPACE_TYPE,
         START_TAG = RES_XML_START_ELEMENT_TYPE,
@@ -750,29 +750,29 @@ public:
     int32_t getCommentID() const;
     const char16_t* getComment(size_t* outLen) const;
     uint32_t getLineNumber() const;
-    
+
     // This is available for TEXT:
     int32_t getTextID() const;
     const char16_t* getText(size_t* outLen) const;
     ssize_t getTextValue(Res_value* outValue) const;
-    
+
     // These are available for START_NAMESPACE and END_NAMESPACE:
     int32_t getNamespacePrefixID() const;
     const char16_t* getNamespacePrefix(size_t* outLen) const;
     int32_t getNamespaceUriID() const;
     const char16_t* getNamespaceUri(size_t* outLen) const;
-    
+
     // These are available for START_TAG and END_TAG:
     int32_t getElementNamespaceID() const;
     const char16_t* getElementNamespace(size_t* outLen) const;
     int32_t getElementNameID() const;
     const char16_t* getElementName(size_t* outLen) const;
-    
+
     // Remaining methods are for retrieving information about attributes
     // associated with a START_TAG:
-    
+
     size_t getAttributeCount() const;
-    
+
     // Returns -1 if no namespace, -2 if idx out of range.
     int32_t getAttributeNamespaceID(size_t idx) const;
     const char16_t* getAttributeNamespace(size_t idx, size_t* outLen) const;
@@ -787,7 +787,7 @@ public:
 
     int32_t getAttributeValueStringID(size_t idx) const;
     const char16_t* getAttributeStringValue(size_t idx, size_t* outLen) const;
-    
+
     int32_t getAttributeDataType(size_t idx) const;
     int32_t getAttributeData(size_t idx) const;
     ssize_t getAttributeValue(size_t idx, Res_value* outValue) const;
@@ -808,7 +808,7 @@ public:
 
 private:
     friend class ResXMLTree;
-    
+
     event_code_t nextNode();
 
     const ResXMLTree&           mTree;
@@ -947,7 +947,7 @@ struct ResTable_config
 {
     // Number of bytes in this structure.
     uint32_t size;
-    
+
     union {
         struct {
             // Mobile country code (from SIM).  0 means "any".
@@ -957,7 +957,7 @@ struct ResTable_config
         };
         uint32_t imsi;
     };
-    
+
     union {
         struct {
             // This field can take three different forms:
@@ -983,7 +983,7 @@ struct ResTable_config
             // The layout is always bigendian irrespective of the runtime
             // architecture.
             char language[2];
-            
+
             // This field can take three different forms:
             // - \0\0 means "any".
             //
@@ -1000,21 +1000,21 @@ struct ResTable_config
         };
         uint32_t locale;
     };
-    
+
     enum {
         ORIENTATION_ANY  = ACONFIGURATION_ORIENTATION_ANY,
         ORIENTATION_PORT = ACONFIGURATION_ORIENTATION_PORT,
         ORIENTATION_LAND = ACONFIGURATION_ORIENTATION_LAND,
         ORIENTATION_SQUARE = ACONFIGURATION_ORIENTATION_SQUARE,
     };
-    
+
     enum {
         TOUCHSCREEN_ANY  = ACONFIGURATION_TOUCHSCREEN_ANY,
         TOUCHSCREEN_NOTOUCH  = ACONFIGURATION_TOUCHSCREEN_NOTOUCH,
         TOUCHSCREEN_STYLUS  = ACONFIGURATION_TOUCHSCREEN_STYLUS,
         TOUCHSCREEN_FINGER  = ACONFIGURATION_TOUCHSCREEN_FINGER,
     };
-    
+
     enum {
         DENSITY_DEFAULT = ACONFIGURATION_DENSITY_DEFAULT,
         DENSITY_LOW = ACONFIGURATION_DENSITY_LOW,
@@ -1027,7 +1027,7 @@ struct ResTable_config
         DENSITY_ANY = ACONFIGURATION_DENSITY_ANY,
         DENSITY_NONE = ACONFIGURATION_DENSITY_NONE
     };
-    
+
     union {
         struct {
             uint8_t orientation;
@@ -1036,14 +1036,14 @@ struct ResTable_config
         };
         uint32_t screenType;
     };
-    
+
     enum {
         KEYBOARD_ANY  = ACONFIGURATION_KEYBOARD_ANY,
         KEYBOARD_NOKEYS  = ACONFIGURATION_KEYBOARD_NOKEYS,
         KEYBOARD_QWERTY  = ACONFIGURATION_KEYBOARD_QWERTY,
         KEYBOARD_12KEY  = ACONFIGURATION_KEYBOARD_12KEY,
     };
-    
+
     enum {
         NAVIGATION_ANY  = ACONFIGURATION_NAVIGATION_ANY,
         NAVIGATION_NONAV  = ACONFIGURATION_NAVIGATION_NONAV,
@@ -1051,7 +1051,7 @@ struct ResTable_config
         NAVIGATION_TRACKBALL  = ACONFIGURATION_NAVIGATION_TRACKBALL,
         NAVIGATION_WHEEL  = ACONFIGURATION_NAVIGATION_WHEEL,
     };
-    
+
     enum {
         MASK_KEYSHIDDEN = 0x0003,
         KEYSHIDDEN_ANY = ACONFIGURATION_KEYSHIDDEN_ANY,
@@ -1059,7 +1059,7 @@ struct ResTable_config
         KEYSHIDDEN_YES = ACONFIGURATION_KEYSHIDDEN_YES,
         KEYSHIDDEN_SOFT = ACONFIGURATION_KEYSHIDDEN_SOFT,
     };
-    
+
     enum {
         MASK_NAVHIDDEN = 0x000c,
         SHIFT_NAVHIDDEN = 2,
@@ -1067,7 +1067,7 @@ struct ResTable_config
         NAVHIDDEN_NO = ACONFIGURATION_NAVHIDDEN_NO << SHIFT_NAVHIDDEN,
         NAVHIDDEN_YES = ACONFIGURATION_NAVHIDDEN_YES << SHIFT_NAVHIDDEN,
     };
-    
+
     union {
         struct {
             uint8_t keyboard;
@@ -1077,15 +1077,15 @@ struct ResTable_config
         };
         uint32_t input;
     };
-    
+
     enum {
         SCREENWIDTH_ANY = 0
     };
-    
+
     enum {
         SCREENHEIGHT_ANY = 0
     };
-    
+
     union {
         struct {
             uint16_t screenWidth;
@@ -1093,15 +1093,15 @@ struct ResTable_config
         };
         uint32_t screenSize;
     };
-    
+
     enum {
         SDKVERSION_ANY = 0
     };
-    
+
   enum {
         MINORVERSION_ANY = 0
     };
-    
+
     union {
         struct {
             uint16_t sdkVersion;
@@ -1111,7 +1111,7 @@ struct ResTable_config
         };
         uint32_t version;
     };
-    
+
     enum {
         // screenLayout bits for screen size class.
         MASK_SCREENSIZE = 0x0f,
@@ -1120,7 +1120,7 @@ struct ResTable_config
         SCREENSIZE_NORMAL = ACONFIGURATION_SCREENSIZE_NORMAL,
         SCREENSIZE_LARGE = ACONFIGURATION_SCREENSIZE_LARGE,
         SCREENSIZE_XLARGE = ACONFIGURATION_SCREENSIZE_XLARGE,
-        
+
         // screenLayout bits for wide/long screen variation.
         MASK_SCREENLONG = 0x30,
         SHIFT_SCREENLONG = 4,
@@ -1135,7 +1135,7 @@ struct ResTable_config
         LAYOUTDIR_LTR = ACONFIGURATION_LAYOUTDIR_LTR << SHIFT_LAYOUTDIR,
         LAYOUTDIR_RTL = ACONFIGURATION_LAYOUTDIR_RTL << SHIFT_LAYOUTDIR,
     };
-    
+
     enum {
         // uiMode bits for the mode type.
         MASK_UI_MODE_TYPE = 0x0f,
@@ -1164,7 +1164,7 @@ struct ResTable_config
         };
         uint32_t screenConfig;
     };
-    
+
     union {
         struct {
             uint16_t screenWidthDp;
@@ -1228,9 +1228,9 @@ struct ResTable_config
     char localeNumberingSystem[8];
 
     void copyFromDeviceNoSwap(const ResTable_config& o);
-    
+
     void copyFromDtoH(const ResTable_config& o);
-    
+
     void swapHtoD();
 
     int compare(const ResTable_config& o) const;
@@ -1260,11 +1260,11 @@ struct ResTable_config
         CONFIG_SCREEN_ROUND = ACONFIGURATION_SCREEN_ROUND,
         CONFIG_COLOR_MODE = ACONFIGURATION_COLOR_MODE,
     };
-    
+
     // Compare two configuration, returning CONFIG_* flags set for each value
     // that is different.
     int diff(const ResTable_config& o) const;
-    
+
     // Return true if 'this' is more specific than 'o'.
     bool isMoreSpecificThan(const ResTable_config& o) const;
 
@@ -1280,7 +1280,7 @@ struct ResTable_config
     // it wins.  If this IS generic, o wins (return false).
     bool isBetterThan(const ResTable_config& o, const ResTable_config* requested) const;
 
-    // Return true if 'this' can be considered a match for the parameters in 
+    // Return true if 'this' can be considered a match for the parameters in
     // 'settings'.
     // Note this is asymetric.  A default piece of data will match every request
     // but a request for the default should not match odd specifics
@@ -1374,12 +1374,12 @@ struct ResTable_typeSpec
     // at 1 (corresponding to the value of the type bits in a
     // resource identifier).  0 is invalid.
     uint8_t id;
-    
+
     // Must be 0.
     uint8_t res0;
     // Must be 0.
     uint16_t res1;
-    
+
     // Number of uint32_t entry configuration masks that follow.
     uint32_t entryCount;
 
@@ -1425,12 +1425,12 @@ struct ResTable_type
     enum {
         NO_ENTRY = 0xFFFFFFFF
     };
-    
+
     // The type identifier this chunk is holding.  Type IDs start
     // at 1 (corresponding to the value of the type bits in a
     // resource identifier).  0 is invalid.
     uint8_t id;
-    
+
     enum {
         // If set, the entry is sparse, and encodes both the entry ID and offset into each entry,
         // and a binary search is used to find the key. Only available on platforms >= O.
@@ -1442,7 +1442,7 @@ struct ResTable_type
 
     // Must be 0.
     uint16_t reserved;
-    
+
     // Number of uint32_t entry indices that follow.
     uint32_t entryCount;
 
@@ -1506,7 +1506,7 @@ struct ResTable_entry
         FLAG_WEAK = 0x0004,
     };
     uint16_t flags;
-    
+
     // Reference into ResTable_package::keyStrings identifying this entry.
     struct ResStringPool_ref key;
 };
@@ -1558,7 +1558,7 @@ struct ResTable_map
         ATTR_TWO = Res_MAKEINTERNAL(7),
         ATTR_FEW = Res_MAKEINTERNAL(8),
         ATTR_MANY = Res_MAKEINTERNAL(9)
-        
+
     };
 
     // Bit mask of allowed types, for use with ATTR_TYPE.
@@ -1608,7 +1608,7 @@ struct ResTable_map
         L10N_NOT_REQUIRED = 0,
         L10N_SUGGESTED    = 1
     };
-    
+
     // This mapping's value.
     Res_value value;
 };
@@ -1978,7 +1978,7 @@ public:
         uint32_t getChangingConfigurations() const;
 
         void dumpToLog() const;
-        
+
     private:
         Theme(const Theme&);
         Theme& operator=(const Theme&);
@@ -2072,7 +2072,7 @@ public:
     // resolve resources that do not exist in this ResTable.  If 'attrType' is
     // supplied, the value will be type checked for this format if 'attrID'
     // is not supplied or found.
-    bool stringToValue(Res_value* outValue, String16* outString,
+    bool stringToValue(const ssize_t FORCED_PACKAGE_ID, Res_value* outValue, String16* outString,
                        const char16_t* s, size_t len,
                        bool preserveSpaces, bool coerceType,
                        uint32_t attrID = 0,
diff --git a/tools/aapt/AaptAssets.cpp b/tools/aapt/AaptAssets.cpp
index 899d26818548..bc6bc5e6815e 100644
--- a/tools/aapt/AaptAssets.cpp
+++ b/tools/aapt/AaptAssets.cpp
@@ -36,6 +36,8 @@ static const String8 kResString(kResourceDir);
  */
 static bool validateFileName(const char* fileName)
 {
+    // Apktool: Don't validate filename.
+    return true;
     const char* cp = fileName;
     size_t len = 0;
 
@@ -1056,7 +1058,7 @@ ssize_t AaptAssets::slurpFromArgs(Bundle* bundle)
                 return UNKNOWN_ERROR;
             }
         }
-        
+
     }
     /*
      * Now do any additional raw files.
@@ -1618,6 +1620,8 @@ sp<AaptDir> AaptAssets::resDir(const String8& name) const
 bool
 valid_symbol_name(const String8& symbol)
 {
+    // Apktool: Don't validate symbol name.
+    return true;
     static char const * const KEYWORDS[] = {
         "abstract", "assert", "boolean", "break",
         "byte", "case", "catch", "char", "class", "const", "continue",
diff --git a/tools/aapt/AaptConfig.cpp b/tools/aapt/AaptConfig.cpp
index 0aca45ea8d60..b754d5b7aefc 100644
--- a/tools/aapt/AaptConfig.cpp
+++ b/tools/aapt/AaptConfig.cpp
@@ -260,6 +260,8 @@ bool parseCommaSeparatedList(const String8& str, std::set<ConfigDescription>* ou
 }
 
 void applyVersionForCompatibility(ConfigDescription* config) {
+    // Apktool: Don't apply implicit version during build.
+    return;
     if (config == NULL) {
         return;
     }
@@ -315,7 +317,7 @@ bool parseMcc(const char* name, ResTable_config* out) {
         c++;
     }
     if (*c != 0) return false;
-    if (c-val != 3) return false;
+    if (c-val != 3 && c-val != 4) return false;
 
     int d = atoi(val);
     if (d != 0) {
@@ -345,7 +347,7 @@ bool parseMnc(const char* name, ResTable_config* out) {
         c++;
     }
     if (*c != 0) return false;
-    if (c-val == 0 || c-val > 3) return false;
+    if (c-val == 0 || c-val > 4) return false;
 
     if (out) {
         out->mnc = atoi(val);
@@ -543,6 +545,27 @@ bool parseUiModeType(const char* name, ResTable_config* out) {
               (out->uiMode&~ResTable_config::MASK_UI_MODE_TYPE)
               | ResTable_config::UI_MODE_TYPE_VR_HEADSET;
         return true;
+    } else if (strcmp(name, "smallui") == 0) {
+      if (out) out->uiMode =
+               (out->uiMode&~ResTable_config::MASK_UI_MODE_TYPE)
+               | 0xC;
+        return true;
+    } else if (strcmp(name, "mediumui") == 0) {
+      if (out) out->uiMode =
+               (out->uiMode&ResTable_config::MASK_UI_MODE_TYPE)
+               | 0xD;
+        return true;
+    } else if (strcmp(name, "largeui") == 0) {
+      if (out) out->uiMode =
+               (out->uiMode&ResTable_config::MASK_UI_MODE_TYPE)
+               | 0xE;
+        return true;
+    } else if (strcmp(name, "hugeui") == 0) {
+      if (out) out->uiMode = 0xF;
+        return true;
+    } else if (strcmp(name, "godzillaui") == 0) {
+      if (out) out->uiMode = 0xB;
+        return true;
     }
 
     return false;
diff --git a/tools/aapt/Android.bp b/tools/aapt/Android.bp
index cc10db9e1523..ab5b3adab025 100644
--- a/tools/aapt/Android.bp
+++ b/tools/aapt/Android.bp
@@ -51,6 +51,8 @@ cc_defaults {
         "libz",
     ],
 
+    static_executable: true,
+
     cflags: [
         "-Wall",
         "-Werror",
@@ -59,6 +61,10 @@ cc_defaults {
     target: {
         windows: {
             enabled: true,
+            ldflags: ["-static"],
+        },
+        linux: {
+            static_libs: ["libc++_static"],
         },
     },
 }
@@ -111,8 +117,16 @@ cc_binary_host {
     name: "aapt",
     defaults: ["aapt_defaults"],
     srcs: ["Main.cpp"],
+    stl: "libc++_static",
     use_version_lib: true,
+    static_executable: true,
     static_libs: ["libaapt"],
+    compile_multilib: "both",
+    multilib: {
+        lib64: {
+            suffix: "_64",
+        },
+    },
     dist: {
         targets: ["aapt2_artifacts"],
     },
diff --git a/tools/aapt/Bundle.h b/tools/aapt/Bundle.h
index deb9cc083eb0..ffe08447936f 100644
--- a/tools/aapt/Bundle.h
+++ b/tools/aapt/Bundle.h
@@ -58,7 +58,7 @@ public:
           mNoVersionTransitions(false),
           mCrunchedOutputDir(NULL), mProguardFile(NULL), mMainDexProguardFile(NULL),
           mAndroidManifestFile(NULL), mPublicOutputFile(NULL),
-          mRClassDir(NULL), mResourceIntermediatesDir(NULL), mManifestMinSdkVersion(NULL),
+          mRClassDir(NULL), mResourceIntermediatesDir(NULL), mForcedPackageId(-1), mManifestMinSdkVersion(NULL),
           mMinSdkVersion(NULL), mTargetSdkVersion(NULL), mMaxSdkVersion(NULL),
           mVersionCode(NULL), mVersionName(NULL), mReplaceVersion(false), mCustomPackage(NULL),
           mExtraPackages(NULL), mMaxResVersion(NULL), mDebugMode(false), mNonConstantId(false),
@@ -180,6 +180,8 @@ public:
     const android::String8& getFeatureOfPackage() const { return mFeatureOfPackage; }
     void setFeatureAfterPackage(const char* str) { mFeatureAfterPackage = str; }
     const android::String8& getFeatureAfterPackage() const { return mFeatureAfterPackage; }
+    int getForcedPackageId() const { return mForcedPackageId; }
+    void setForcedPackageId(int val) { mForcedPackageId = val; }
 
     const char*  getManifestMinSdkVersion() const { return mManifestMinSdkVersion; }
     void setManifestMinSdkVersion(const char*  val) { mManifestMinSdkVersion = val; }
@@ -327,6 +329,7 @@ private:
     android::String8 mFeatureOfPackage;
     android::String8 mFeatureAfterPackage;
     android::String8 mRevisionCode;
+    int         mForcedPackageId;
     const char* mManifestMinSdkVersion;
     const char* mMinSdkVersion;
     const char* mTargetSdkVersion;
diff --git a/tools/aapt/Main.cpp b/tools/aapt/Main.cpp
index 2f2ef92e72b4..42df727e8bf4 100644
--- a/tools/aapt/Main.cpp
+++ b/tools/aapt/Main.cpp
@@ -16,6 +16,7 @@
 #include <cstdlib>
 #include <getopt.h>
 #include <cassert>
+#include <fstream>
 
 using namespace android;
 
@@ -72,8 +73,8 @@ void usage(void)
         "   xmlstrings       Print the strings of the given compiled xml assets.\n\n", gProgName);
     fprintf(stderr,
         " %s p[ackage] [-d][-f][-m][-u][-v][-x][-z][-M AndroidManifest.xml] \\\n"
-        "        [-0 extension [-0 extension ...]] [-g tolerance] [-j jarfile] \\\n"
-        "        [--debug-mode] [--min-sdk-version VAL] [--target-sdk-version VAL] \\\n"
+        "        [-0 extension [-0 extension ...]] [-e extensions_file] [-g tolerance] [-j jarfile] \\\n"
+        "        [--debug-mode] [--forced-package-id VAL] [--min-sdk-version VAL] [--target-sdk-version VAL] \\\n"
         "        [--app-version VAL] [--app-version-name TEXT] [--custom-package VAL] \\\n"
         "        [--rename-manifest-package PACKAGE] \\\n"
         "        [--rename-instrumentation-target-package PACKAGE] \\\n"
@@ -146,6 +147,8 @@ void usage(void)
         "   -0  specifies an additional extension for which such files will not\n"
         "       be stored compressed in the .apk.  An empty string means to not\n"
         "       compress any files at all.\n"
+        "   -e  specifies path to a file containing a list of additional extensions for which such files will not\n"
+        "       be stored compressed in the .apk.\n"
         "   --debug-mode\n"
         "       inserts android:debuggable=\"true\" in to the application node of the\n"
         "       manifest, making the application debuggable even on production devices.\n"
@@ -153,6 +156,8 @@ void usage(void)
         "       when used with \"dump badging\" also includes meta-data tags.\n"
         "   --pseudo-localize\n"
         "       generate resources for pseudo-locales (en-XA and ar-XB).\n"
+        "   --forced-package-id\n"
+        "       forces value as package-id\n"
         "   --min-sdk-version\n"
         "       inserts android:minSdkVersion in to manifest.  If the version is 7 or\n"
         "       higher, the default encoding for resources will be in UTF-8.\n"
@@ -522,7 +527,7 @@ int main(int argc, char* const argv[])
                 argc--;
                 argv++;
                 if (!argc) {
-                    fprintf(stderr, "ERROR: No argument supplied for '-e' option\n");
+                    fprintf(stderr, "ERROR: No argument supplied for '-0' option\n");
                     wantUsage = true;
                     goto bail;
                 }
@@ -532,9 +537,38 @@ int main(int argc, char* const argv[])
                     bundle.setCompressionMethod(ZipEntry::kCompressStored);
                 }
                 break;
+            case 'e': {
+                argc--;
+                argv++;
+                if (!argc) {
+                    fprintf(stderr, "ERROR: No argument supplied for '-e' option\n");
+                    wantUsage = true;
+                    goto bail;
+                }
+                std::ifstream extensionsFile(argv[0]);
+
+                if (extensionsFile.fail()) {
+                    fprintf(stderr, "ERROR: Could not open extensions file %s for reading\n", argv[0]);
+                    goto bail;
+                }
+
+                for (std::string line; getline(extensionsFile, line);) {
+                    bundle.addNoCompressExtension(line.c_str());
+                }
+                break;
+            }
             case '-':
                 if (strcmp(cp, "-debug-mode") == 0) {
                     bundle.setDebugMode(true);
+                } else if (strcmp(cp, "-forced-package-id") == 0) {
+                    argc--;
+                    argv++;
+                    if (!argc) {
+                        fprintf(stderr, "ERROR: No argument supplied for '--forced-package-id' option\n");
+                        wantUsage = true;
+                        goto bail;
+                    }
+                    bundle.setForcedPackageId(atoi(argv[0]));
                 } else if (strcmp(cp, "-min-sdk-version") == 0) {
                     argc--;
                     argv++;
diff --git a/tools/aapt/Resource.cpp b/tools/aapt/Resource.cpp
index dd3ebdbdea09..282a098f47d8 100644
--- a/tools/aapt/Resource.cpp
+++ b/tools/aapt/Resource.cpp
@@ -267,6 +267,19 @@ static status_t parsePackage(Bundle* bundle, const sp<AaptAssets>& assets,
         bundle->setRevisionCode(String8(block.getAttributeStringValue(revisionCodeIndex, &len)).string());
     }
 
+    // Extract platformBuild info from current AndroidManifest.xml
+    ssize_t platformBuildVersionCodeIndex = block.indexOfAttribute(NULL, "platformBuildVersionCode");
+    if (platformBuildVersionCodeIndex >= 0) {
+        const char16_t* platformBuildVersionCode16 = block.getAttributeStringValue(platformBuildVersionCodeIndex, &len);
+        bundle->setPlatformBuildVersionCode(String8(platformBuildVersionCode16));
+    }
+
+    ssize_t platformBuildVersionNameIndex = block.indexOfAttribute(NULL, "platformBuildVersionName");
+    if (platformBuildVersionNameIndex >= 0) {
+        const char16_t* platformBuildVersionName16 = block.getAttributeStringValue(platformBuildVersionNameIndex, &len);
+        bundle->setPlatformBuildVersionName(String8(platformBuildVersionName16));
+    }
+
     String16 uses_sdk16("uses-sdk");
     while ((code=block.next()) != ResXMLTree::END_DOCUMENT
            && code != ResXMLTree::BAD_DOCUMENT) {
@@ -312,9 +325,10 @@ static status_t makeFileResources(Bundle* bundle, const sp<AaptAssets>& assets,
         const char16_t* const end = str + baseName.size();
         while (str < end) {
             if (!((*str >= 'a' && *str <= 'z')
+                    || (*str >= 'A' && *str <= 'Z')
                     || (*str >= '0' && *str <= '9')
-                    || *str == '_' || *str == '.')) {
-                fprintf(stderr, "%s: Invalid file name: must contain only [a-z0-9_.]\n",
+                    || *str == '_' || *str == '.' || *str == '$')) {
+                fprintf(stderr, "%s: Invalid file name: must contain only [a-zA-Z0-9$_.]\n",
                         it.getPath().string());
                 hasErrors = true;
             }
@@ -495,7 +509,7 @@ static int validateAttr(const String8& path, const ResTable& table,
                         value.data);
                 return ATTR_NOT_FOUND;
             }
-            
+
             pool = table.getTableStringBlock(strIdx);
             #if 0
             if (pool != NULL) {
@@ -548,7 +562,6 @@ static int validateAttr(const String8& path, const ResTable& table,
                     fprintf(stderr, "%s:%d: Tag <%s> attribute %s has invalid character '%c'.\n",
                             path.string(), parser.getLineNumber(),
                             String8(parser.getElementName(&len)).string(), attr, (char)str[i]);
-                    return (int)i;
                 }
             }
         }
@@ -735,7 +748,7 @@ bool addTagAttribute(const sp<XMLNode>& node, const char* ns8,
         // don't stop the build.
         return true;
     }
-    
+
     node->addAttribute(ns, attr, String16(value));
     return true;
 }
@@ -886,7 +899,7 @@ status_t massageManifest(Bundle* bundle, ResourceTable* table, sp<XMLNode> root)
             bundle->setVersionName(strdup(String8(attr->string).string()));
         }
     }
-    
+
     sp<XMLNode> vers = root->getChildElement(String16(), String16("uses-sdk"));
     if (bundle->getMinSdkVersion() != NULL
             || bundle->getTargetSdkVersion() != NULL
@@ -895,7 +908,7 @@ status_t massageManifest(Bundle* bundle, ResourceTable* table, sp<XMLNode> root)
             vers = XMLNode::newElement(root->getFilename(), String16(), String16("uses-sdk"));
             root->insertChildAt(vers, 0);
         }
-        
+
         if (!addTagAttribute(vers, RESOURCES_ANDROID_NAMESPACE, "minSdkVersion",
                 bundle->getMinSdkVersion(), errorOnFailedInsert)) {
             return UNKNOWN_ERROR;
@@ -1011,7 +1024,7 @@ status_t massageManifest(Bundle* bundle, ResourceTable* table, sp<XMLNode> root)
             }
         }
     }
-    
+
     sp<XMLNode> application = root->getChildElement(String16(), String16("application"));
     if (application != NULL) {
         XMLNode::attribute_entry* icon_attr = application->editAttribute(
@@ -1137,8 +1150,7 @@ static ssize_t extractPlatformBuildVersion(AssetManager& assets, Bundle* bundle)
 
     Asset* asset = assets.openNonAsset(cookie, "AndroidManifest.xml", Asset::ACCESS_STREAMING);
     if (asset == NULL) {
-        fprintf(stderr, "ERROR: Platform AndroidManifest.xml not found\n");
-        return UNKNOWN_ERROR;
+        return NO_ERROR;
     }
 
     ssize_t result = NO_ERROR;
@@ -1314,7 +1326,7 @@ status_t buildResources(Bundle* bundle, const sp<AaptAssets>& assets, sp<ApkBuil
     // --------------------------------------------------------------
 
     // resType -> leafName -> group
-    KeyedVector<String8, sp<ResourceTypeSet> > *resources = 
+    KeyedVector<String8, sp<ResourceTypeSet> > *resources =
             new KeyedVector<String8, sp<ResourceTypeSet> >;
     collect_files(assets, resources);
 
@@ -1348,7 +1360,7 @@ status_t buildResources(Bundle* bundle, const sp<AaptAssets>& assets, sp<ApkBuil
     // now go through any resource overlays and collect their files
     sp<AaptAssets> current = assets->getOverlay();
     while(current.get()) {
-        KeyedVector<String8, sp<ResourceTypeSet> > *resources = 
+        KeyedVector<String8, sp<ResourceTypeSet> > *resources =
                 new KeyedVector<String8, sp<ResourceTypeSet> >;
         current->setResources(resources);
         collect_files(current, resources);
@@ -1459,7 +1471,7 @@ status_t buildResources(Bundle* bundle, const sp<AaptAssets>& assets, sp<ApkBuil
     // compile resources
     current = assets;
     while(current.get()) {
-        KeyedVector<String8, sp<ResourceTypeSet> > *resources = 
+        KeyedVector<String8, sp<ResourceTypeSet> > *resources =
                 current->getResources();
 
         ssize_t index = resources->indexOfKey(String8("values"));
@@ -1468,7 +1480,7 @@ status_t buildResources(Bundle* bundle, const sp<AaptAssets>& assets, sp<ApkBuil
             ssize_t res;
             while ((res=it.next()) == NO_ERROR) {
                 const sp<AaptFile>& file = it.getFile();
-                res = compileResourceFile(bundle, assets, file, it.getParams(), 
+                res = compileResourceFile(bundle, assets, file, it.getParams(),
                                           (current!=assets), &table);
                 if (res != NO_ERROR) {
                     hasErrors = true;
@@ -1728,7 +1740,7 @@ status_t buildResources(Bundle* bundle, const sp<AaptAssets>& assets, sp<ApkBuil
     if (table.validateLocalizations()) {
         hasErrors = true;
     }
-    
+
     if (hasErrors) {
         return UNKNOWN_ERROR;
     }
@@ -1779,7 +1791,7 @@ status_t buildResources(Bundle* bundle, const sp<AaptAssets>& assets, sp<ApkBuil
 
     ResTable finalResTable;
     sp<AaptFile> resFile;
-    
+
     if (table.hasResources()) {
         sp<AaptSymbols> symbols = assets->getSymbolsFor(String8("R"));
         err = table.addSymbols(symbols, bundle->getSkipSymbolsWithoutDefaultLocalization());
@@ -2001,7 +2013,7 @@ status_t buildResources(Bundle* bundle, const sp<AaptAssets>& assets, sp<ApkBuil
                 ssize_t index = block.indexOfAttribute(RESOURCES_ANDROID_NAMESPACE, "name");
                 const char16_t* id = block.getAttributeStringValue(index, &len);
                 if (id == NULL) {
-                    fprintf(stderr, "%s:%d: missing name attribute in element <%s>.\n", 
+                    fprintf(stderr, "%s:%d: missing name attribute in element <%s>.\n",
                             manifestPath.string(), block.getLineNumber(),
                             String8(block.getElementName(&len)).string());
                     hasErrors = true;
@@ -2190,7 +2202,7 @@ status_t buildResources(Bundle* bundle, const sp<AaptAssets>& assets, sp<ApkBuil
             return err;
         }
     }
-    
+
     return err;
 }
 
@@ -2464,7 +2476,7 @@ static status_t writeLayoutClasses(
         fprintf(fp, "%s */\n", getIndentSpace(indent));
 
         ann.printAnnotations(fp, indentStr);
-        
+
         fprintf(fp,
                 "%spublic static final int[] %s = {\n"
                 "%s",
diff --git a/tools/aapt/ResourceTable.cpp b/tools/aapt/ResourceTable.cpp
index b9de11b0026b..b0d52dc3123c 100644
--- a/tools/aapt/ResourceTable.cpp
+++ b/tools/aapt/ResourceTable.cpp
@@ -63,7 +63,7 @@ status_t compileXmlFile(const Bundle* bundle,
     if (root == NULL) {
         return UNKNOWN_ERROR;
     }
-    
+
     return compileXmlFile(bundle, assets, resourceName, root, outTarget, table, options);
 }
 
@@ -99,7 +99,7 @@ status_t compileXmlFile(const Bundle* bundle,
     if (table->processBundleFormat(bundle, resourceName, target, root) != NO_ERROR) {
         return UNKNOWN_ERROR;
     }
-    
+
     bool hasErrors = false;
     if ((options&XML_COMPILE_ASSIGN_ATTRIBUTE_IDS) != 0) {
         status_t err = root->assignResourceIds(assets, table);
@@ -109,7 +109,7 @@ status_t compileXmlFile(const Bundle* bundle,
     }
 
     if ((options&XML_COMPILE_PARSE_VALUES) != 0) {
-        status_t err = root->parseValues(assets, table);
+        status_t err = root->parseValues(bundle, assets, table);
         if (err != NO_ERROR) {
             hasErrors = true;
         }
@@ -142,7 +142,7 @@ status_t compileXmlFile(const Bundle* bundle,
     }
 
     target->setCompressionMethod(ZipEntry::kCompressDeflated);
-    
+
     return err;
 }
 
@@ -258,7 +258,7 @@ static String16 mayOrMust(int type, int flags)
     if ((type&(~flags)) == 0) {
         return String16("<p>Must");
     }
-    
+
     return String16("<p>May");
 }
 
@@ -297,7 +297,7 @@ struct PendingAttribute
     String16 comment;
     bool hasErrors;
     bool added;
-    
+
     PendingAttribute(String16 _package, const sp<AaptFile>& in,
             ResXMLTree& block, bool _appendComment)
         : myPackage(_package)
@@ -308,7 +308,7 @@ struct PendingAttribute
         , added(false)
     {
     }
-    
+
     status_t createIfNeeded(ResourceTable* outTable)
     {
         if (added || hasErrors) {
@@ -332,7 +332,7 @@ static status_t compileAttribute(const sp<AaptFile>& in,
                                  bool inStyleable = false)
 {
     PendingAttribute attr(myPackage, in, block, inStyleable);
-    
+
     const String16 attr16("attr");
     const String16 id16("id");
 
@@ -343,7 +343,7 @@ static status_t compileAttribute(const sp<AaptFile>& in,
     ResXMLTree::event_code_t code;
     size_t len;
     status_t err;
-    
+
     ssize_t identIdx = block.indexOfAttribute(NULL, "name");
     if (identIdx >= 0) {
         attr.ident = String16(block.getAttributeStringValue(identIdx, &len));
@@ -438,7 +438,7 @@ static status_t compileAttribute(const sp<AaptFile>& in,
     }
 
     String16 enumOrFlagsComment;
-    
+
     while ((code=block.next()) != ResXMLTree::END_DOCUMENT && code != ResXMLTree::BAD_DOCUMENT) {
         if (code == ResXMLTree::START_TAG) {
             uint32_t localType = 0;
@@ -454,7 +454,7 @@ static status_t compileAttribute(const sp<AaptFile>& in,
             }
 
             attr.createIfNeeded(outTable);
-            
+
             if (attr.type == ResTable_map::TYPE_ANY) {
                 // No type was explicitly stated, so supplying enum tags
                 // implicitly creates an enum or flag.
@@ -526,7 +526,7 @@ static status_t compileAttribute(const sp<AaptFile>& in,
                                                 "<colgroup align=\"left\" />\n"
                                                 "<tr><th>Constant</th><th>Value</th><th>Description</th></tr>"));
                 }
-                
+
                 enumOrFlagsComment.append(String16("\n<tr><td><code>"));
                 enumOrFlagsComment.append(itemIdent);
                 enumOrFlagsComment.append(String16("</code></td><td>"));
@@ -536,7 +536,7 @@ static status_t compileAttribute(const sp<AaptFile>& in,
                     enumOrFlagsComment.append(String16(block.getComment(&len)));
                 }
                 enumOrFlagsComment.append(String16("</td></tr>"));
-                
+
                 err = outTable->addBag(SourcePos(in->getPrintableSource(), block.getLineNumber()),
                                        myPackage,
                                        attr16, attr.ident, String16(""),
@@ -566,11 +566,11 @@ static status_t compileAttribute(const sp<AaptFile>& in,
             }
         }
     }
-    
+
     if (!attr.hasErrors && attr.added) {
         appendTypeInfo(outTable, myPackage, attr16, attr.ident, attr.type, gFormatFlags);
     }
-    
+
     if (!attr.hasErrors && enumOrFlagsComment.size() > 0) {
         enumOrFlagsComment.append(String16("\n</table>"));
         outTable->appendTypeComment(myPackage, attr16, attr.ident, enumOrFlagsComment);
@@ -707,7 +707,7 @@ status_t parseAndAddEntry(Bundle* bundle,
                             curTag, &str, curIsStyled ? &spans : NULL,
                             isFormatted, pseudolocalize);
 
-    if (err < NO_ERROR) { 
+    if (err < NO_ERROR) {
         return err;
     }
 
@@ -941,7 +941,7 @@ status_t compileResourceFile(Bundle* bundle,
 
             } else if (strcmp16(block.getElementName(&len), public16.string()) == 0) {
                 SourcePos srcPos(in->getPrintableSource(), block.getLineNumber());
-            
+
                 String16 type;
                 ssize_t typeIdx = block.indexOfAttribute(NULL, "type");
                 if (typeIdx < 0) {
@@ -1013,7 +1013,7 @@ status_t compileResourceFile(Bundle* bundle,
 
             } else if (strcmp16(block.getElementName(&len), public_padding16.string()) == 0) {
                 SourcePos srcPos(in->getPrintableSource(), block.getLineNumber());
-            
+
                 String16 type;
                 ssize_t typeIdx = block.indexOfAttribute(NULL, "type");
                 if (typeIdx < 0) {
@@ -1074,7 +1074,7 @@ status_t compileResourceFile(Bundle* bundle,
                             start, end);
                     hasErrors = localHasErrors = true;
                 }
-                
+
                 String16 comment(
                     block.getComment(&len) ? block.getComment(&len) : nulStr);
                 for (uint32_t curIdent=start; curIdent<=end; curIdent++) {
@@ -1085,7 +1085,7 @@ status_t compileResourceFile(Bundle* bundle,
                     char buf[64];
                     sprintf(buf, "%d", (int)(end-curIdent+1));
                     curName.append(String16(buf));
-                    
+
                     err = outTable->addEntry(srcPos, myPackage, type, curName,
                                              String16("padding"), NULL, &curParams, false,
                                              ResTable_map::TYPE_STRING, overwrite);
@@ -1153,7 +1153,7 @@ status_t compileResourceFile(Bundle* bundle,
 
             } else if (strcmp16(block.getElementName(&len), java_symbol16.string()) == 0) {
                 SourcePos srcPos(in->getPrintableSource(), block.getLineNumber());
-            
+
                 String16 type;
                 ssize_t typeIdx = block.indexOfAttribute(NULL, "type");
                 if (typeIdx < 0) {
@@ -1196,7 +1196,7 @@ status_t compileResourceFile(Bundle* bundle,
 
             } else if (strcmp16(block.getElementName(&len), add_resource16.string()) == 0) {
                 SourcePos srcPos(in->getPrintableSource(), block.getLineNumber());
-            
+
                 String16 typeName;
                 ssize_t typeIdx = block.indexOfAttribute(NULL, "type");
                 if (typeIdx < 0) {
@@ -1223,10 +1223,10 @@ status_t compileResourceFile(Bundle* bundle,
                     }
                 }
                 continue;
-                
+
             } else if (strcmp16(block.getElementName(&len), declare_styleable16.string()) == 0) {
                 SourcePos srcPos(in->getPrintableSource(), block.getLineNumber());
-                                
+
                 String16 ident;
                 ssize_t identIdx = block.indexOfAttribute(NULL, "name");
                 if (identIdx < 0) {
@@ -1248,7 +1248,7 @@ status_t compileResourceFile(Bundle* bundle,
                         srcPos.error("Unable to create symbols!\n");
                         return UNKNOWN_ERROR;
                     }
-                    
+
                     String16 comment(
                         block.getComment(&len) ? block.getComment(&len) : nulStr);
                     styleSymbols->appendComment(String8(ident), comment, srcPos);
@@ -1369,7 +1369,7 @@ status_t compileResourceFile(Bundle* bundle,
                         formatted.setTo(block.getAttributeStringValue(i, &length));
                     }
                 }
-                
+
                 if (name.size() > 0) {
                     if (locale.size() == 0) {
                         outTable->addDefaultLocalization(name);
@@ -1530,7 +1530,7 @@ status_t compileResourceFile(Bundle* bundle,
             }
 
             String16 comment(block.getComment(&len) ? block.getComment(&len) : nulStr);
-            
+
             if (curIsBag) {
                 // Figure out the parent of this bag...
                 String16 parentIdent;
@@ -1553,7 +1553,7 @@ status_t compileResourceFile(Bundle* bundle,
                         hasErrors = localHasErrors = true;
                     }
                 }
-                
+
                 ssize_t elmIndex = 0;
                 char elmIndexStr[14];
                 while ((code=block.next()) != ResXMLTree::END_DOCUMENT
@@ -1763,24 +1763,26 @@ ResourceTable::ResourceTable(Bundle* bundle, const String16& assetsPackage, Reso
     , mNumLocal(0)
     , mBundle(bundle)
 {
-    ssize_t packageId = -1;
-    switch (mPackageType) {
-        case App:
-        case AppFeature:
-            packageId = 0x7f;
-            break;
+    ssize_t packageId = mBundle->getForcedPackageId();
+    if (packageId == -1) {
+        switch (mPackageType) {
+            case App:
+            case AppFeature:
+                packageId = 0x7f;
+                break;
 
-        case System:
-            packageId = 0x01;
-            break;
+            case System:
+                packageId = 0x01;
+                break;
 
-        case SharedLibrary:
-            packageId = 0x00;
-            break;
+            case SharedLibrary:
+                packageId = 0x00;
+                break;
 
-        default:
-            assert(0);
-            break;
+            default:
+                assert(0);
+                break;
+        }
     }
     sp<Package> package = new Package(mAssetsPackage, packageId);
     mPackages.add(assetsPackage, package);
@@ -1822,7 +1824,7 @@ status_t ResourceTable::addIncludedResources(Bundle* bundle, const sp<AaptAssets
 
         const ResTable& featureTable = featureAssetManager.getResources(false);
         mTypeIdOffset = std::max(mTypeIdOffset,
-                findLargestTypeIdForPackage(featureTable, mAssetsPackage)); 
+                findLargestTypeIdForPackage(featureTable, mAssetsPackage));
     }
 
     return NO_ERROR;
@@ -1872,7 +1874,7 @@ status_t ResourceTable::addEntry(const SourcePos& sourcePos,
                 String8(type).string(), String8(name).string(), String8(package).string());
         return UNKNOWN_ERROR;
     }
-    
+
     sp<Entry> e = getEntry(package, type, name, sourcePos, overwrite,
                            params, doSetIndex);
     if (e == NULL) {
@@ -1929,7 +1931,7 @@ status_t ResourceTable::startBag(const SourcePos& sourcePos,
     if (e == NULL) {
         return UNKNOWN_ERROR;
     }
-    
+
     // If a parent is explicitly specified, set it.
     if (bagParent.size() > 0) {
         e->setParent(bagParent);
@@ -1939,7 +1941,7 @@ status_t ResourceTable::startBag(const SourcePos& sourcePos,
         return result;
     }
 
-    if (overlay && replace) { 
+    if (overlay && replace) {
         return e->emptyBag(sourcePos);
     }
     return result;
@@ -2090,7 +2092,7 @@ bool ResourceTable::appendTypeComment(const String16& package,
     if (comment.size() <= 0) {
         return true;
     }
-    
+
     sp<Package> p = mPackages.valueFor(package);
     if (p != NULL) {
         sp<Type> t = p->getTypes().valueFor(type);
@@ -2219,7 +2221,7 @@ uint32_t ResourceTable::getResId(const String16& package,
                 return 0;
             }
         }
-        
+
         return ResourceIdCache::store(package, type, name, onlyPublic, rid);
     }
 
@@ -2315,7 +2317,7 @@ bool ResourceTable::stringToValue(Res_value* outValue, StringPool* pool,
     if (style == NULL || style->size() == 0) {
         // Text is not styled so it can be any type...  let's figure it out.
         res = mAssets->getIncludedResources()
-            .stringToValue(outValue, &finalStr, str.string(), str.size(), preserveSpaces,
+            .stringToValue(mBundle->getForcedPackageId(), outValue, &finalStr, str.string(), str.size(), preserveSpaces,
                             coerceType, attrID, NULL, &mAssetsPackage, this,
                            accessorCookie, attrType);
     } else {
@@ -2355,7 +2357,7 @@ bool ResourceTable::stringToValue(Res_value* outValue, StringPool* pool,
             // Caller will fill this in later.
             outValue->data = 0;
         }
-    
+
         if (outStr) {
             *outStr = finalStr;
         }
@@ -2656,9 +2658,6 @@ status_t ResourceTable::assignResourceIds()
             const size_t N = t->getOrderedConfigs().size();
             t->setIndex(ti + 1 + typeIdOffset);
 
-            LOG_ALWAYS_FATAL_IF(ti == 0 && attr != t,
-                                "First type is not attr!");
-
             for (size_t ei=0; ei<N; ei++) {
                 sp<ConfigList> c = t->getOrderedConfigs().itemAt(ei);
                 if (c == NULL) {
@@ -2759,7 +2758,7 @@ status_t ResourceTable::addSymbols(const sp<AaptSymbols>& outSymbols,
                     }
 
                     typeSymbols->addSymbol(String8(c->getName()), rid, c->getPos());
-                    
+
                     String16 comment(c->getComment());
                     typeSymbols->appendComment(String8(c->getName()), comment, c->getPos());
                     //printf("Type symbol [%08x] %s comment: %s\n", rid,
@@ -3083,7 +3082,7 @@ status_t ResourceTable::flatten(Bundle* bundle, const sp<const ResourceFilter>&
             // the item at t->getOrderedConfigs().itemAt(i).
             Vector<bool> validResources;
             validResources.insertAt(false, 0, N);
-            
+
             // First write the typeSpec chunk, containing information about
             // each resource entry in this type.
             {
@@ -3101,7 +3100,7 @@ status_t ResourceTable::flatten(Bundle* bundle, const sp<const ResourceFilter>&
                 tsHeader->header.size = htodl(typeSpecSize);
                 tsHeader->id = ti+1;
                 tsHeader->entryCount = htodl(N);
-                
+
                 uint32_t* typeSpecFlags = (uint32_t*)
                     (((uint8_t*)data->editData())
                         + typeSpecStart + sizeof(ResTable_typeSpec));
@@ -3136,7 +3135,7 @@ status_t ResourceTable::flatten(Bundle* bundle, const sp<const ResourceFilter>&
                     }
                 }
             }
-            
+
             if (skipEntireType) {
                 continue;
             }
@@ -3147,9 +3146,9 @@ status_t ResourceTable::flatten(Bundle* bundle, const sp<const ResourceFilter>&
             if (t != NULL) {
                 uniqueConfigs = t->getUniqueConfigs();
             }
-            
+
             const size_t typeSize = sizeof(ResTable_type) + sizeof(uint32_t)*N;
-            
+
             const size_t NC = uniqueConfigs.size();
             for (size_t ci=0; ci<NC; ci++) {
                 const ConfigDescription& config = uniqueConfigs[ci];
@@ -3178,11 +3177,11 @@ status_t ResourceTable::flatten(Bundle* bundle, const sp<const ResourceFilter>&
                         config.screenHeightDp,
                         config.screenLayout);
                 }
-                      
+
                 if (filterable && !filter->match(config)) {
                     continue;
                 }
-                
+
                 const size_t typeStart = data->getSize();
 
                 ResTable_type* tHeader = (ResTable_type*)
@@ -3308,7 +3307,7 @@ status_t ResourceTable::flatten(Bundle* bundle, const sp<const ResourceFilter>&
             return err;
         }
     }
-    
+
     ssize_t strStart = dest->getSize();
     status_t err = valueStrings.writeStringBlock(dest);
     if (err != NO_ERROR) {
@@ -3339,7 +3338,7 @@ status_t ResourceTable::flatten(Bundle* bundle, const sp<const ResourceFilter>&
         fprintf(stderr, "**** total resource table size: %zu / %zu%% strings\n",
                 dest->getSize(), (size_t)(strAmt*100)/dest->getSize());
     }
-    
+
     return NO_ERROR;
 }
 
@@ -3560,7 +3559,7 @@ status_t ResourceTable::Entry::addToBag(const SourcePos& sourcePos,
     }
 
     Item item(sourcePos, isId, value, style, format);
-    
+
     // XXX NOTE: there is an error if you try to have a bag with two keys,
     // one an attr and one an id, with the same name.  Not something we
     // currently ever have to worry about.
@@ -3657,7 +3656,7 @@ status_t ResourceTable::Entry::assignResourceIds(ResourceTable* table,
                                                  const String16& /* package */)
 {
     bool hasErrors = false;
-    
+
     if (mType == TYPE_BAG) {
         const char* errorMsg;
         const String16 style16("style");
@@ -3795,7 +3794,7 @@ ssize_t ResourceTable::Entry::flatten(Bundle* /* bundle */, const sp<AaptFile>&
             items.add(it.bagKeyId, &it);
         }
         N = items.size();
-        
+
         ResTable_map_entry mapHeader;
         memcpy(&mapHeader, &header, sizeof(header));
         mapHeader.size = htods(sizeof(mapHeader));
@@ -3928,10 +3927,10 @@ sp<ResourceTable::Entry> ResourceTable::Type::getEntry(const String16& entry,
             c->setEntryIndex(pos);
         }
     }
-    
+
     ConfigDescription cdesc;
     if (config) cdesc = *config;
-    
+
     sp<Entry> e = c->getEntries().valueFor(cdesc);
     if (e == NULL) {
         if (kIsDebug) {
@@ -3981,7 +3980,7 @@ sp<ResourceTable::Entry> ResourceTable::Type::getEntry(const String16& entry,
         }
         */
     }
-    
+
     return e;
 }
 
@@ -4082,12 +4081,12 @@ status_t ResourceTable::Type::applyPublicEntryOrder()
     }
 
     //printf("Copying back in %d non-public configs, have %d\n", N, origOrder.size());
-    
+
     if (N != origOrder.size()) {
         printf("Internal error: remaining private symbol count mismatch\n");
         N = origOrder.size();
     }
-    
+
     j = 0;
     for (i=0; i<N; i++) {
         const sp<ConfigList>& e = origOrder.itemAt(i);
@@ -4383,7 +4382,7 @@ sp<const ResourceTable::Entry> ResourceTable::getEntry(uint32_t resID,
         fprintf(stderr, "warning: Entry not found for resource #%08x\n", resID);
         return NULL;
     }
-    
+
     ConfigDescription cdesc;
     if (config) cdesc = *config;
     sp<Entry> e = c->getEntries().valueFor(cdesc);
@@ -4391,7 +4390,7 @@ sp<const ResourceTable::Entry> ResourceTable::getEntry(uint32_t resID,
         fprintf(stderr, "warning: Entry configuration not found for resource #%08x\n", resID);
         return NULL;
     }
-    
+
     return e;
 }
 
@@ -4609,6 +4608,8 @@ bool ResourceTable::shouldGenerateVersionedResource(
  * attribute will be respected.
  */
 status_t ResourceTable::modifyForCompat(const Bundle* bundle) {
+    // Apktool: Don't modify for compatibility.
+    return NO_ERROR;
     const int minSdk = getMinSdkVersion(bundle);
     if (minSdk >= SDK_LOLLIPOP_MR1) {
         // Lollipop MR1 and up handles public attributes differently, no
@@ -4839,6 +4840,8 @@ status_t ResourceTable::modifyForCompat(const Bundle* bundle,
                                         const String16& resourceName,
                                         const sp<AaptFile>& target,
                                         const sp<XMLNode>& root) {
+    // Apktool: Skip compatibility checks
+    return NO_ERROR;
     const String16 vector16("vector");
     const String16 animatedVector16("animated-vector");
     const String16 pathInterpolator16("pathInterpolator");
diff --git a/tools/aapt/XMLNode.cpp b/tools/aapt/XMLNode.cpp
index 69392d66e21f..15b1622fc9e8 100644
--- a/tools/aapt/XMLNode.cpp
+++ b/tools/aapt/XMLNode.cpp
@@ -971,7 +971,7 @@ void XMLNode::removeWhitespace(bool stripAll, const char** cDataTags)
     }
 }
 
-status_t XMLNode::parseValues(const sp<AaptAssets>& assets,
+status_t XMLNode::parseValues(const Bundle* bundle, const sp<AaptAssets>& assets,
                               ResourceTable* table)
 {
     bool hasErrors = false;
@@ -985,7 +985,7 @@ status_t XMLNode::parseValues(const sp<AaptAssets>& assets,
                     String8(e.string));
             table->setCurrentXmlPos(SourcePos(mFilename, getStartLineNumber()));
             if (!assets->getIncludedResources()
-                    .stringToValue(&e.value, &e.string,
+                    .stringToValue(bundle->getForcedPackageId(), &e.value, &e.string,
                                   e.string.string(), e.string.size(), true, true,
                                   e.nameResId, NULL, &defPackage, table, &ac)) {
                 hasErrors = true;
@@ -999,7 +999,7 @@ status_t XMLNode::parseValues(const sp<AaptAssets>& assets,
     }
     const size_t N = mChildren.size();
     for (size_t i=0; i<N; i++) {
-        status_t err = mChildren.itemAt(i)->parseValues(assets, table);
+        status_t err = mChildren.itemAt(i)->parseValues(bundle, assets, table);
         if (err != NO_ERROR) {
             hasErrors = true;
         }
diff --git a/tools/aapt/XMLNode.h b/tools/aapt/XMLNode.h
index ac920186fe63..aa8b3aa40c76 100644
--- a/tools/aapt/XMLNode.h
+++ b/tools/aapt/XMLNode.h
@@ -45,12 +45,12 @@ public:
     sp<XMLNode> newNamespace(const String8& filename, const String16& prefix, const String16& uri) {
         return new XMLNode(filename, prefix, uri, true);
     }
-    
+
     static inline
     sp<XMLNode> newElement(const String8& filename, const String16& ns, const String16& name) {
         return new XMLNode(filename, ns, name, false);
     }
-    
+
     static inline
     sp<XMLNode> newCData(const String8& filename) {
         return new XMLNode(filename);
@@ -61,19 +61,19 @@ public:
         TYPE_ELEMENT,
         TYPE_CDATA
     };
-    
+
     type getType() const;
-    
+
     const String16& getNamespacePrefix() const;
     const String16& getNamespaceUri() const;
-    
+
     const String16& getElementNamespace() const;
     const String16& getElementName() const;
     const Vector<sp<XMLNode> >& getChildren() const;
     Vector<sp<XMLNode> >& getChildren();
 
     const String8& getFilename() const;
-    
+
     struct attribute_entry {
         attribute_entry() : index(~(uint32_t)0), nameResId(0)
         {
@@ -81,11 +81,10 @@ public:
         }
 
         bool needStringValue() const {
-            return nameResId == 0
-                || value.dataType == Res_value::TYPE_NULL
+            return value.dataType == Res_value::TYPE_NULL
                 || value.dataType == Res_value::TYPE_STRING;
         }
-        
+
         String16 ns;
         String16 name;
         String16 string;
@@ -99,7 +98,7 @@ public:
 
     const attribute_entry* getAttribute(const String16& ns, const String16& name) const;
     bool removeAttribute(const String16& ns, const String16& name);
-    
+
     attribute_entry* editAttribute(const String16& ns, const String16& name);
 
     const String16& getCData() const;
@@ -110,9 +109,9 @@ public:
     int32_t getEndLineNumber() const;
 
     sp<XMLNode> searchElement(const String16& tagNamespace, const String16& tagName);
-    
+
     sp<XMLNode> getChildElement(const String16& tagNamespace, const String16& tagName);
-    
+
     status_t addChild(const sp<XMLNode>& child);
 
     status_t insertChildAt(const sp<XMLNode>& child, size_t index);
@@ -135,7 +134,7 @@ public:
 
     void setUTF8(bool val) { mUTF8 = val; }
 
-    status_t parseValues(const sp<AaptAssets>& assets, ResourceTable* table);
+    status_t parseValues(const Bundle* bundle, const sp<AaptAssets>& assets, ResourceTable* table);
 
     status_t assignResourceIds(const sp<AaptAssets>& assets,
                                const ResourceTable* table = NULL);
@@ -167,25 +166,25 @@ private:
     endElement(void *userData, const char *name);
     static void XMLCALL
     endNamespace(void *userData, const char *prefix);
-    
+
     static void XMLCALL
     commentData(void *userData, const char *comment);
-    
+
     // For cloning
     XMLNode();
 
     // Creating an element node.
     XMLNode(const String8& filename, const String16& s1, const String16& s2, bool isNamespace);
-    
+
     // Creating a CDATA node.
     explicit XMLNode(const String8& filename);
-    
+
     status_t collect_strings(StringPool* dest, Vector<uint32_t>* outResIds,
             bool stripComments, bool stripRawValues) const;
 
     status_t collect_attr_strings(StringPool* outPool,
         Vector<uint32_t>* outResIds, bool allAttrs) const;
-        
+
     status_t collect_resid_strings(StringPool* outPool,
             Vector<uint32_t>* outResIds) const;
 
